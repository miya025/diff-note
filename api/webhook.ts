import type { VercelRequest, VercelResponse } from '@vercel/node';
import crypto from 'crypto';
import { GitHubClient } from '../src/github';
import { LLMClient } from '../src/llm';
import { shouldSkipPR, categorizeFiles } from '../src/skip';
import { PullRequestInfo } from '../src/types';

function verifyWebhookSignature(req: VercelRequest): boolean {
  const signature = req.headers['x-hub-signature-256'] as string;
  const secret = process.env.GITHUB_WEBHOOK_SECRET;
  if (!signature || !secret) return false;

  const hmac = crypto.createHmac('sha256', secret);
  const digest = 'sha256=' + hmac.update(JSON.stringify(req.body)).digest('hex');

  try {
    return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(digest));
  } catch {
    return false;
  }
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  if (process.env.GITHUB_WEBHOOK_SECRET && !verifyWebhookSignature(req)) {
    return res.status(401).json({ error: 'Invalid signature' });
  }

  const event = req.headers['x-github-event'] as string;
  const payload = req.body;

  if (event !== 'pull_request') {
    return res.status(200).json({ message: 'Ignored event', event });
  }

  const action = payload.action;
  if (!['opened', 'synchronize', 'reopened'].includes(action)) {
    return res.status(200).json({ message: 'Ignored action', action });
  }

  try {
    await processPullRequest(payload);
    return res.status(200).json({ message: 'Processed' });
  } catch (error) {
    console.error('Error processing PR:', error);
    return res.status(500).json({ error: 'Processing failed' });
  }
}

async function processPullRequest(payload: {
  pull_request: {
    number: number;
    title: string;
    body: string | null;
    base: { sha: string };
    head: { sha: string };
    labels: Array<{ name: string }>;
  };
  repository: { owner: { login: string }; name: string };
}) {
  const githubToken = process.env.GITHUB_TOKEN;
  const anthropicKey = process.env.ANTHROPIC_API_KEY;

  if (!githubToken || !anthropicKey) {
    throw new Error('Missing required environment variables');
  }

  const github = new GitHubClient(githubToken);
  const llm = new LLMClient(anthropicKey);

  const owner = payload.repository.owner.login;
  const repo = payload.repository.name;
  const pullNumber = payload.pull_request.number;

  console.log(`Processing PR #${pullNumber} in ${owner}/${repo}`);

  const pr: PullRequestInfo = {
    owner,
    repo,
    number: pullNumber,
    title: payload.pull_request.title,
    body: payload.pull_request.body,
    base: payload.pull_request.base.sha,
    head: payload.pull_request.head.sha,
    labels: payload.pull_request.labels.map(l => l.name),
  };

  const diff = await github.getPRDiff(owner, repo, pullNumber);

  const skipCheck = shouldSkipPR(pr, diff);
  if (skipCheck.shouldSkip) {
    console.log(`Skipping PR #${pullNumber}: ${skipCheck.reason}`);
    return;
  }

  const categories = categorizeFiles(diff);
  console.log(`Files: ${categories.source.length} source, ${categories.tests.length} tests, ${categories.docs.length} docs`);

  const docs = await llm.generatePRSummary(diff, pr.title);

  let comment = `## PR Summary (AI Generated)\n\n${docs.prSummary}`;

  if (docs.readmeChanges) {
    comment += `\n\n---\n\n### README追記候補\n\n\`\`\`markdown\n${docs.readmeChanges}\n\`\`\``;
  }

  const adr = await llm.generateADR(diff, pr.title, pr.body);
  if (adr) {
    comment += `\n\n---\n\n### ADRドラフト\n\n<details>\n<summary>クリックして展開</summary>\n\n${adr}\n\n</details>`;
  }

  comment += '\n\n---\n*Generated by diff-note*';

  await github.postPRComment(owner, repo, pullNumber, comment);
  console.log(`Posted comment to PR #${pullNumber}`);
}
